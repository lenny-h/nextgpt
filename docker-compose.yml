# Docker Compose configuration for local development
# Includes PostgreSQL with pgvector extension, Redis, and MinIO
# See DOCKER_SETUP.md for detailed documentation

name: mono

services:
  # PostgreSQL Database with pgvector extension
  postgres:
    container_name: postgres
    image: firecrawl-postgres:latest # firecrawl-postgres for Firecrawl, else use pgvector/pgvector:pg18
    restart: unless-stopped
    ports:
      - "5432:5432"
    volumes:
      - ./packages/server/src/drizzle/0000_sloppy_micromacro.sql:/docker-entrypoint-initdb.d/0000_sloppy_micromacro.sql:ro # Only required for Firecrawl
      - ./packages/server/src/drizzle/0001_tearful_firedrake.sql:/docker-entrypoint-initdb.d/0001_tearful_firedrake.sql:ro
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 10
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: postgres
      POSTGRES_INITDB_ARGS: "-E UTF8"
    command:
      - "postgres"
      - "-c"
      - "shared_preload_libraries=vector,pg_cron" # pg_cron is only needed for Firecrawl
    networks:
      - database_network

  # Redis Cache for local development
  redis:
    container_name: redis
    image: redis:7.2.11-alpine
    restart: unless-stopped
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    command: redis-server --appendonly yes
    volumes:
      - redis-data:/data
    networks:
      - database_network

  # MinIO - S3-compatible object storage for local development
  minio:
    container_name: minio
    image: minio/minio:RELEASE.2025-07-23T15-54-02Z
    restart: unless-stopped
    ports:
      - "9000:9000"  # API port
      - "9001:9001"  # Console port
    volumes:
      - minio-data:/data
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - database_network

  # MinIO bucket initialization
  minio-init:
    container_name: minio-init
    image: minio/mc:RELEASE.2025-07-21T05-28-08Z
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set myminio http://minio:9000 ${MINIO_ROOT_USER} ${MINIO_ROOT_PASSWORD};
      mc mb --ignore-existing myminio/files-bucket;
      mc mb --ignore-existing myminio/temporary-files-bucket;
      echo 'Buckets created successfully';
      exit 0;
      "
    networks:
      - database_network

  # The services below need not be run in Docker
  # It is better to run them using `pnpm run dev` due to hot-reloading

  # Custom API Service
  api:
    container_name: api
    user: root
    build:
      context: .
      dockerfile: apps/api/Dockerfile
    restart: unless-stopped
    ports:
      - "3004:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock # Required to spawn document processor containers
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--spider",
          "http://localhost:8080/api/public/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    environment:
      PORT: 8080
      NODE_ENV: development

      # ==============================
      # Authentication configuration
      # ==============================

      # Better Auth configuration and Resend email service (for sending verification emails)
      BETTER_AUTH_URL: http://localhost:3004
      BETTER_AUTH_SECRET: ${BETTER_AUTH_SECRET}
      ONLY_ALLOW_ADMIN_TO_CREATE_BUCKETS: ${ONLY_ALLOW_ADMIN_TO_CREATE_BUCKETS}
      ADMIN_USER_IDS: ${ADMIN_USER_IDS}

      ENABLE_EMAIL_SIGNUP: ${ENABLE_EMAIL_SIGNUP}
      ALLOWED_EMAIL_DOMAINS: ${ALLOWED_EMAIL_DOMAINS}

      ENABLE_OAUTH_LOGIN: ${ENABLE_OAUTH_LOGIN}
      # Google OAuth
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      # GitHub OAuth
      GITHUB_CLIENT_ID: ${GITHUB_CLIENT_ID}
      GITHUB_CLIENT_SECRET: ${GITHUB_CLIENT_SECRET}
      # Gitlab OAuth
      GITLAB_CLIENT_ID: ${GITLAB_CLIENT_ID}
      GITLAB_CLIENT_SECRET: ${GITLAB_CLIENT_SECRET}

      # SSO Configuration
      ENABLE_SSO: ${ENABLE_SSO}
      SSO_DOMAIN: ${SSO_DOMAIN}
      SSO_PROVIDER_ID: ${SSO_PROVIDER_ID}
      SSO_CLIENT_ID: ${SSO_CLIENT_ID}
      SSO_CLIENT_SECRET: ${SSO_CLIENT_SECRET}
      SSO_ISSUER: ${SSO_ISSUER}
      SSO_AUTHORIZATION_ENDPOINT: ${SSO_AUTHORIZATION_ENDPOINT}
      SSO_DISCOVERY_ENDPOINT: ${SSO_DISCOVERY_ENDPOINT}
      SSO_TOKEN_ENDPOINT: ${SSO_TOKEN_ENDPOINT}
      SSO_JWKS_ENDPOINT: ${SSO_JWKS_ENDPOINT}

      RESEND_SENDER_EMAIL: ${RESEND_SENDER_EMAIL}
      RESEND_API_KEY: ${RESEND_API_KEY}

      # ==============================
      # Application configuration
      # ==============================
  
      BASE_URL: http://localhost:3000
      ALLOWED_ORIGINS: "http://localhost:3000,http://localhost:3001"
      API_URL: http://host.docker.internal:3004

      # Database and Redis
      DATABASE_PASSWORD: ${DATABASE_PASSWORD}
      DATABASE_HOST: postgres:5432
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      REDIS_URL: "redis://redis:6379"

      USE_LOCAL_TASKS_CLIENT: ${USE_LOCAL_TASKS_CLIENT}
      USE_LOCAL_FILE_STORAGE: ${USE_LOCAL_FILE_STORAGE}
      USE_CLOUDFLARE_R2: ${USE_CLOUDFLARE_R2}
      USE_OPENAI_API: ${USE_OPENAI_API}
      OPENAI_API_KEY: ${OPENAI_API_KEY}

      # Local MinIO configuration
      MINIO_ENDPOINT: http://minio:9000
      MINIO_PUBLIC_ENDPOINT: http://localhost:9000 # Needed because browser cannot reach http://minio:9000
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}

      # Cloudflare R2 configuration
      R2_ENDPOINT: ${R2_ENDPOINT}
      CLOUDFLARE_ACCESS_KEY_ID: ${CLOUDFLARE_ACCESS_KEY_ID}
      CLOUDFLARE_SECRET_ACCESS_KEY: ${CLOUDFLARE_SECRET_ACCESS_KEY}

      EMBEDDINGS_MODEL: ${EMBEDDINGS_MODEL}
      EMBEDDING_DIMENSIONS: ${EMBEDDING_DIMENSIONS}
      LLM_MODELS: ${LLM_MODELS}

      # ==============================
      # Firecrawl configuration
      # =============================

      USE_FIRECRAWL: ${USE_FIRECRAWL}
      FIRECRAWL_API_URL: http://firecrawl-api:8080
      FIRECRAWL_API_KEY: ${FIRECRAWL_API_KEY}

      # ==============================
      # Cloud provider configuration
      # =============================

      CLOUD_PROVIDER: ${CLOUD_PROVIDER}

      # # Gcloud configuration
      # GOOGLE_VERTEX_PROJECT: ${GOOGLE_VERTEX_PROJECT}
      # GOOGLE_VERTEX_LOCATION: ${GOOGLE_VERTEX_LOCATION}
      # GOOGLE_PROCESSING_QUEUE: document-processing-queue
      # GOOGLE_DOCUMENT_PROCESSOR_JOB: ${GOOGLE_DOCUMENT_PROCESSOR_JOB}

      # # Aws configuration
      # AWS_REGION: ${AWS_REGION}
      # AWS_PROJECT_NAME: ${AWS_PROJECT_NAME}

      # AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
      # AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}

      # SQS_QUEUE_URL: ${SQS_QUEUE_URL}

      # AWS_SCHEDULER_GROUP: ${AWS_SCHEDULER_GROUP}
      # AWS_SCHEDULER_TARGET_ARN: ${AWS_SCHEDULER_TARGET_ARN}
      # AWS_SCHEDULER_ROLE_ARN: ${AWS_SCHEDULER_ROLE_ARN}
    networks:
      - database_network

  # PDF Exporter Service
  pdf-exporter:
    container_name: pdf-exporter
    build:
      context: .
      dockerfile: apps/pdf-exporter/Dockerfile
    restart: unless-stopped
    ports:
      - "3005:8080"
    depends_on:
      api:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--spider",
          "http://localhost:8080/pdf-exporter/public/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    environment:
      PORT: 8080
      NODE_ENV: development
  
      # ==============================
      # Authentication configuration
      # ==============================
  
      BETTER_AUTH_URL: http://localhost:3004
      BETTER_AUTH_SECRET: ${BETTER_AUTH_SECRET}
      ONLY_ALLOW_ADMIN_TO_CREATE_BUCKETS: ${ONLY_ALLOW_ADMIN_TO_CREATE_BUCKETS}
      ADMIN_USER_IDS: ${ADMIN_USER_IDS}
  
      ENABLE_EMAIL_SIGNUP: ${ENABLE_EMAIL_SIGNUP}
      ALLOWED_EMAIL_DOMAINS: ${ALLOWED_EMAIL_DOMAINS}
  
      ENABLE_OAUTH_LOGIN: ${ENABLE_OAUTH_LOGIN}
      # Google OAuth
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      # GitHub OAuth
      GITHUB_CLIENT_ID: ${GITHUB_CLIENT_ID}
      GITHUB_CLIENT_SECRET: ${GITHUB_CLIENT_SECRET}
      # Gitlab OAuth
      GITLAB_CLIENT_ID: ${GITLAB_CLIENT_ID}
      GITLAB_CLIENT_SECRET: ${GITLAB_CLIENT_SECRET}
  
      # SSO Configuration
      ENABLE_SSO: ${ENABLE_SSO}
      SSO_DOMAIN: ${SSO_DOMAIN}
      SSO_PROVIDER_ID: ${SSO_PROVIDER_ID}
      SSO_CLIENT_ID: ${SSO_CLIENT_ID}
      SSO_CLIENT_SECRET: ${SSO_CLIENT_SECRET}
      SSO_ISSUER: ${SSO_ISSUER}
      SSO_AUTHORIZATION_ENDPOINT: ${SSO_AUTHORIZATION_ENDPOINT}
      SSO_DISCOVERY_ENDPOINT: ${SSO_DISCOVERY_ENDPOINT}
      SSO_TOKEN_ENDPOINT: ${SSO_TOKEN_ENDPOINT}
      SSO_JWKS_ENDPOINT: ${SSO_JWKS_ENDPOINT}
  
      # ==============================
      # Application configuration
      # ==============================
  
      BASE_URL: http://localhost:3000
      ALLOWED_ORIGINS: "http://localhost:3000,http://localhost:3001"
  
      # Database and Redis
      DATABASE_PASSWORD: ${DATABASE_PASSWORD}
      DATABASE_HOST: postgres:5432
      REDIS_URL: "redis://redis:6379"
    networks:
      - database_network

  # # Web interface (Next.js)
  # web:
  #   container_name: web
  #   build:
  #     context: .
  #     dockerfile: apps/web/Dockerfile
  #     args:
  #       NEXT_PUBLIC_BASE_URL: http://localhost:3000
  #       NEXT_PUBLIC_DASHBOARD_URL: http://localhost:3001
  #       NEXT_PUBLIC_API_URL: http://localhost:3004
  #       NEXT_PUBLIC_PDF_EXPORTER_URL: http://localhost:3005
  #       NEXT_PUBLIC_ENABLE_EMAIL_SIGNUP: ${NEXT_PUBLIC_ENABLE_EMAIL_SIGNUP}
  #       NEXT_PUBLIC_ENABLE_OAUTH_LOGIN: ${NEXT_PUBLIC_ENABLE_OAUTH_LOGIN}
  #       NEXT_PUBLIC_ENABLE_SSO: ${NEXT_PUBLIC_ENABLE_SSO}
  #       NEXT_PUBLIC_USE_FIRECRAWL: ${NEXT_PUBLIC_USE_FIRECRAWL}
  #       NEXT_PUBLIC_CSP_ENDPOINTS: ${NEXT_PUBLIC_CSP_ENDPOINTS}
  #   restart: unless-stopped
  #   ports:
  #     - "3000:3000"

  # # Dashboard interface (Next.js)
  # dashboard:
  #   container_name: dashboard
  #   build:
  #     context: .
  #     dockerfile: apps/dashboard/Dockerfile
  #     args:
  #       NEXT_PUBLIC_BASE_URL: http://localhost:3001
  #       NEXT_PUBLIC_CHAT_URL: http://localhost:3000
  #       NEXT_PUBLIC_API_URL: http://localhost:3004
  #       NEXT_PUBLIC_PDF_EXPORTER_URL: http://localhost:3005
  #       NEXT_PUBLIC_ENABLE_EMAIL_SIGNUP: ${NEXT_PUBLIC_ENABLE_EMAIL_SIGNUP}
  #       NEXT_PUBLIC_ENABLE_OAUTH_LOGIN: ${NEXT_PUBLIC_ENABLE_OAUTH_LOGIN}
  #       NEXT_PUBLIC_ENABLE_SSO: ${NEXT_PUBLIC_ENABLE_SSO}
  #       NEXT_PUBLIC_USE_FIRECRAWL: ${NEXT_PUBLIC_USE_FIRECRAWL}
  #       NEXT_PUBLIC_CSP_ENDPOINTS: ${NEXT_PUBLIC_CSP_ENDPOINTS}
  #   restart: unless-stopped
  #   ports:
  #     - "3001:3000"

  # # Firecrawl
  # firecrawl-api:
  #   image: firecrawl-api:latest

  #   ulimits:
  #     nofile:
  #       soft: 65535
  #       hard: 65535
  
  #   environment:
  #     HOST: "0.0.0.0"
  #     PORT: 8080
  #     EXTRACT_WORKER_PORT: 3004
  #     WORKER_PORT: 3005
  #     ENV: local

  #     REDIS_URL: redis://redis:6379
  #     REDIS_RATE_LIMIT_URL: redis://redis:6379
  #     PLAYWRIGHT_MICROSERVICE_URL: ${PLAYWRIGHT_MICROSERVICE_URL:-http://playwright-service:3008/scrape}

  #     NUQ_DATABASE_URL: postgresql://postgres:${DATABASE_PASSWORD}@postgres:5432/postgres

  #     USE_DB_AUTHENTICATION: ${USE_DB_AUTHENTICATION}
  #     SUPABASE_URL: ${SUPABASE_URL}
  #     SUPABASE_ANON_TOKEN: ${SUPABASE_ANON_TOKEN}
  #     SUPABASE_SERVICE_TOKEN: ${SUPABASE_SERVICE_TOKEN}
  #     SELF_HOSTED_WEBHOOK_URL: ${SELF_HOSTED_WEBHOOK_URL}

  #     OPENAI_BASE_URL: ${OPENAI_BASE_URL}
  #     OPENAI_API_KEY: ${OPENAI_API_KEY}

  #     MODEL_NAME: ${MODEL_NAME}
  #     MODEL_EMBEDDING_NAME: ${MODEL_EMBEDDING_NAME}
  #     OLLAMA_BASE_URL: ${OLLAMA_BASE_URL} 

  #     SLACK_WEBHOOK_URL: ${SLACK_WEBHOOK_URL}

  #     # Use if you've set up authentication and want to test with a real API key
  #     TEST_API_KEY: ${TEST_API_KEY}

  #     # This key lets you access the queue admin panel. Change this if your deployment is publicly accessible.
  #     BULL_AUTH_KEY: ${BULL_AUTH_KEY}

  #     POSTHOG_HOST: ${POSTHOG_HOST}
  #     POSTHOG_API_KEY: ${POSTHOG_API_KEY}

  #     SERPER_API_KEY: ${SERPER_API_KEY}
  #     SEARCHAPI_API_KEY: ${SEARCHAPI_API_KEY}
  #     LOGGING_LEVEL: ${LOGGING_LEVEL}
  #     PROXY_SERVER: ${PROXY_SERVER}
  #     PROXY_USERNAME: ${PROXY_USERNAME}
  #     PROXY_PASSWORD: ${PROXY_PASSWORD}
  #     SEARXNG_ENDPOINT: ${SEARXNG_ENDPOINT}
  #     SEARXNG_ENGINES: ${SEARXNG_ENGINES}
  #     SEARXNG_CATEGORIES: ${SEARXNG_CATEGORIES}
  #   depends_on:
  #     - redis
  #     - playwright-service
  #   ports:
  #     - "3007:8080"
  #   command: node dist/src/harness.js --start-docker
  #   networks:
  #     - database_network
    
  # playwright-service:
  #   image: firecrawl-playwright:latest
  #   environment:
  #     PORT: 3008
  #     PROXY_SERVER: ${PROXY_SERVER}
  #     PROXY_USERNAME: ${PROXY_USERNAME}
  #     PROXY_PASSWORD: ${PROXY_PASSWORD}
  #     BLOCK_MEDIA: ${BLOCK_MEDIA}
  #   ports:
  #     - "3008:3008"
  #   networks:
  #     - database_network

  # Keycloak for testing SSO integration
  # Set valid redirect URI in Keycloak to http://localhost:3004/api/auth/sso/callback/keycloak-test
  keycloak:
    image: quay.io/keycloak/keycloak:latest
    container_name: keycloak
    command: start-dev
    environment:
      KEYCLOAK_ADMIN: ${KEYCLOAK_ADMIN}
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
    ports:
      - "8080:8080"
    networks:
      - database_network

volumes:
  postgres-data:
  redis-data:
  minio-data:

networks:
  database_network:
    driver: bridge
